<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>VISIONALTRIX – AI Model Pipeline</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">

  <!-- GSAP -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.29.1.min.js"></script>

  <style>
    :root {
      --bg: #030303;
      --card: rgba(5, 5, 5, 0.35);
      --accent: #ff1e00;
      --accent-soft: rgba(255, 30, 0, 0.25);
      --text: #f8f8f8;
      --muted: rgba(248, 248, 248, 0.55);
      --radius-lg: 1.5rem;
    }
    *, *::before, *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: radial-gradient(circle at 10% 20%, #111 0%, #000 45%, #000 100%);
      color: var(--text);
      font-family: "Poppins", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      position: relative;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 20% 30%, rgba(255, 94, 0, 0.08), transparent 55%),
                  radial-gradient(circle at 80% 10%, rgba(255, 30, 0, 0.06), transparent 50%),
                  radial-gradient(circle at 50% 90%, rgba(255, 94, 0, 0.05), transparent 55%);
      pointer-events: none;
      z-index: -1;
    }
    a { text-decoration: none; color: inherit; }
    .hidden { display: none !important; }
    .fade-up {
      opacity: 0;
      transform: translateY(12px);
      transition: opacity 0.28s ease, transform 0.28s ease;
    }
    .fade-up.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* NAV */
    nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1.8rem;
      z-index: 1000;
      background: rgba(0, 0, 0, 0.42);
      backdrop-filter: blur(18px);
      padding: 1.8rem 2.5rem;
      border-radius: 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 4px 20px rgba(0,0,0,0.35);
    }
    .logo {
      font-family: "Space Grotesk", sans-serif;
      font-weight: 700;
      letter-spacing: 0.12em;
      font-size: 1.05rem;
      display: flex;
      gap: 0.5rem;
      align-items: center;
      text-transform: uppercase;
      white-space: nowrap;
    }
    .logo-dot {
      width: 0.65rem;
      height: 0.65rem;
      background: var(--accent);
      border-radius: 999px;
      box-shadow: 0 0 14px rgba(255, 30, 0, 0.8);
    }
    nav a {
      color: var(--muted);
      text-decoration: none;
      font-weight: 500;
      font-size: 0.95rem;
      transition: 0.2s ease;
    }
    nav a:hover,
    nav a.active {
      color: #fff;
    }
    .nav-cta {
      background: linear-gradient(120deg, rgba(255, 65, 0, 1), rgba(180, 15, 5, 1));
      padding: 0.65rem 1.5rem;
      border-radius: 999px;
      border: none;
      color: white;
      font-size: 0.85rem;
      cursor: pointer;
      box-shadow: 0 6px 20px rgba(255, 30, 0, 0.4);
      transition: transform 0.2s;
      white-space: nowrap;
    }
    .nav-cta:hover {
      transform: translateY(-2px);
    }

    /* PAGE WRAP */
    .page {
      padding: 7rem min(5vw, 4rem) 4.5rem;
    }
    .page-shell {
      width: min(1200px, 94vw);
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 2.6rem;
    }

    .breadcrumb {
      font-size: 0.65rem;
      color: rgba(248, 248, 248, 0.36);
      margin-bottom: 1rem;
    }
    .breadcrumb a {
      color: rgba(248, 248, 248, 0.56);
    }

    .title {
      font-family: "Space Grotesk", sans-serif;
      font-size: clamp(2.4rem, 5vw, 3.4rem);
      font-weight: 800;
      letter-spacing: 0.02em;
      margin-bottom: 0.8rem;
    }
    .subtitle {
      color: var(--muted);
      max-width: 50rem;
      line-height: 1.6;
      margin-bottom: 1.7rem;
    }

    /* SECTION */
    .section-title {
      font-family: "Space Grotesk", sans-serif;
      font-size: 1.4rem;
      margin: 2.7rem 0 1rem;
    }
    .section-sub {
      color: var(--muted);
      margin-bottom: 1.2rem;
      max-width: 48rem;
    }

    /* PIPELINE */
    .pipeline {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
      gap: 1.05rem;
    }
    .pipe-card {
      background: rgba(0, 0, 0, 0.28);
      border: 1px solid rgba(255, 255, 255, 0.03);
      border-radius: 1.1rem;
      padding: 1rem 1.05rem 1.1rem;
      position: relative;
    }
    .pipe-step {
      position: absolute;
      top: 0.8rem;
      right: 0.9rem;
      background: rgba(255, 30, 0, 0.25);
      border-radius: 999px;
      font-size: 0.58rem;
      padding: 0.2rem 0.5rem;
      text-transform: uppercase;
    }
    .pipe-card h3 {
      margin-bottom: 0.4rem;
      font-size: 1rem;
    }
    .pipe-card p {
      font-size: 0.72rem;
      color: var(--muted);
      line-height: 1.35;
    }

    .capability-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1.15rem;
      margin-top: 2.4rem;
    }
    .cap-card {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 1.1rem;
      padding: 1rem 1.15rem;
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      box-shadow: 0 18px 35px rgba(0,0,0,0.45);
    }
    .cap-icon {
      font-size: 1.45rem;
    }
    .cap-card h3 {
      font-size: 0.96rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .cap-card p {
      font-size: 0.68rem;
      color: rgba(255,255,255,0.72);
      line-height: 1.55;
    }

    .ops-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1.15rem;
      margin-top: 2.1rem;
    }
    .ops-card {
      background: rgba(0,0,0,0.38);
      border: 1px solid rgba(255,255,255,0.05);
      border-radius: 1.1rem;
      padding: 1rem 1.1rem;
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
      box-shadow: 0 18px 35px rgba(0,0,0,0.45);
    }
    .ops-card h3 {
      font-size: 0.84rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.88);
    }
    .ops-list {
      list-style: none;
      padding-left: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      font-size: 0.64rem;
      color: rgba(255,255,255,0.75);
    }
    .ops-list li {
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .ops-list li span:last-child {
      color: rgba(255,255,255,0.6);
    }
    .ops-progress span {
      font-size: 0.58rem;
      color: rgba(255,255,255,0.6);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .ops-bar {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      overflow: hidden;
      margin-top: 0.35rem;
    }
    .ops-bar .fill {
      height: 100%;
      background: linear-gradient(120deg, rgba(255,94,0,0.88), rgba(255,150,0,0.88));
      border-radius: inherit;
    }
    

    /* ARCH GRID */
    .arch-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin-top: 1.3rem;
      align-items: stretch;
    }
    .arch-card {
      background: rgba(0, 0, 0, 0.42);
      border: 1px solid rgba(255, 255, 255, 0.07);
      border-radius: 1.2rem;
      padding: 1.15rem 1.25rem 1.35rem;
      box-shadow: 0 24px 45px rgba(0,0,0,0.55);
      position: relative;
      overflow: hidden;
    }
    .arch-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 15% 15%, rgba(255,255,255,0.08), transparent 60%);
      opacity: 0.4;
      pointer-events: none;
    }
    .arch-card > * { position: relative; z-index: 1; }
    h3 { margin: 0 0 0.6rem 0; font-size: 0.92rem; font-family: "Space Grotesk", sans-serif; }
    /* Container to preserve exact size */
    .telemetry-wrap { display: block; width: 100%; }
    #telemetryChart { width: 100%; height: 240px; }

    /* INFERENCE PANEL */
    .inference-panel {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 1.4rem;
      padding: 1.45rem 1.6rem 1.9rem;
      position: relative;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      box-shadow: 0 28px 48px rgba(0,0,0,0.54);
    }
    .inference-panel::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 20% 20%, rgba(255, 94, 0, 0.12), transparent 55%),
                  radial-gradient(circle at 80% 10%, rgba(255, 30, 0, 0.18), transparent 45%);
      pointer-events: none;
      opacity: 0.4;
    }
    .inference-panel > * {
      position: relative;
      z-index: 1;
    }
    .inference-section {
      margin-top: 3rem;
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
    }
    .inference-header h2 {
      font-family: "Space Grotesk", sans-serif;
      font-size: clamp(1.8rem, 3vw, 2.2rem);
      letter-spacing: 0.02em;
      margin-bottom: 0.4rem;
    }
    .inference-header p {
      max-width: 48rem;
      color: rgba(248, 248, 248, 0.62);
      line-height: 1.6;
      font-size: 0.85rem;
    }
    .inference-shell {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1.2rem;
      align-items: start;
      position: relative;
    }
    .inference-summary {
      background: rgba(0, 0, 0, 0.42);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 1.3rem;
      padding: 1.5rem 1.4rem;
      box-shadow: 0 22px 44px rgba(0,0,0,0.5);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .inference-summary h3 {
      font-size: 1.1rem;
      margin-bottom: 0.4rem;
    }
    .inference-summary p {
      font-size: 0.8rem;
      color: rgba(248,248,248,0.65);
      line-height: 1.55;
    }
    .inference-summary ul {
      display: flex;
      flex-direction: column;
      gap: 0.7rem;
      margin: 0;
      padding: 0;
      list-style: none;
    }
    .inference-summary li {
      display: flex;
      gap: 0.6rem;
      align-items: flex-start;
      font-size: 0.75rem;
      color: rgba(248,248,248,0.7);
    }
    .inference-summary li span {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 1.35rem;
      height: 1.35rem;
      border-radius: 0.45rem;
      background: rgba(255, 94, 0, 0.22);
      color: rgba(255,255,255,0.85);
      font-size: 0.68rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin-top: 0.08rem;
    }
    .model-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      background: rgba(255, 30, 0, 0.14);
      border: 1px solid rgba(255, 95, 0, 0.45);
      border-radius: 999px;
      font-size: 0.62rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 0.32rem 0.95rem;
      color: rgba(255,255,255,0.9);
      margin-bottom: 0.75rem;
      box-shadow: 0 0 28px rgba(255, 30, 0, 0.18);
    }
    .inference-panel label {
      display: block;
      font-size: 0.75rem;
      color: rgba(248, 248, 248, 0.9);
      margin-bottom: 0.4rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    .inference-panel textarea,
    .inference-panel input,
    .inference-panel select {
      width: 100%;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 0.7rem;
      padding: 0.68rem 0.85rem;
      color: #fff;
      font-size: 0.82rem;
      line-height: 1.4;
      margin-bottom: 0.7rem;
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s;
    }
    .inference-panel textarea:focus,
    .inference-panel input:focus,
    .inference-panel select:focus {
      outline: none;
      border-color: rgba(255, 94, 0, 0.65);
      background: rgba(255, 255, 255, 0.08);
      box-shadow: 0 0 0 2px rgba(255, 94, 0, 0.15);
      transform: translateY(-1px);
    }
    .inference-panel select option {
      background: rgba(15, 15, 15, 0.95);
      color: rgba(248, 248, 248, 0.92);
    }
    .inference-panel select option:hover,
    .inference-panel select option:checked {
      background: rgba(255, 94, 0, 0.45);
      color: #fff;
    }
    .input-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 0.6rem;
    }
    .ghost-btn {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 999px;
      padding: 0.5rem 1.1rem;
      color: rgba(255,255,255,0.9);
      font-size: 0.68rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .ghost-btn:hover {
      background: rgba(255,255,255,0.14);
      transform: translateY(-1px);
    }
    .conditions-note {
      font-size: 0.58rem;
      color: rgba(255,255,255,0.6);
      margin-bottom: 0.55rem;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }
    .conditions-note::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: linear-gradient(130deg, rgba(255,94,0,0.85), rgba(255,30,0,0.65));
      box-shadow: 0 0 12px rgba(255, 50, 0, 0.45);
    }
    .conditions-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .conditions-grid .field {
      display: flex;
      flex-direction: column;
    }
    .conditions-grid label {
      margin-bottom: 0.25rem;
    }
    .conditions-grid input,
    .conditions-grid select {
      margin-bottom: 0;
    }
    .run-btn {
      background: linear-gradient(130deg, rgba(255,30,0,1) 0%, rgba(255,94,0,0.95) 55%, rgba(255,150,0,0.9) 100%);
      border: none;
      border-radius: 999px;
      padding: 0.75rem 1.6rem;
      color: #fff;
      font-size: 0.82rem;
      cursor: pointer;
      margin-top: 0.5rem;
      font-weight: 650;
      letter-spacing: 0.05em;
      box-shadow: 0 18px 45px rgba(255, 94, 0, 0.38);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
    }
    .infer-output {
      margin-top: 0.7rem;
      background: rgba(0,0,0,0.38);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 0.75rem;
      padding: 0.6rem 0.7rem;
      font-size: 0.72rem;
      color: rgba(248,248,248,0.8);
      min-height: 54px;
      white-space: pre-wrap;
    }
    .run-btn:hover {
      transform: translateY(-2px) scale(1.01);
      box-shadow: 0 24px 55px rgba(255, 94, 0, 0.45);
    }
    .infer-results {
      margin-top: 0.75rem;
      background: rgba(0, 0, 0, 0.42);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 1.1rem;
      padding: 0.95rem 1.05rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
      box-shadow: 0 20px 35px rgba(0,0,0,0.55);
    }
    .result-head {
      display: flex;
      justify-content: space-between;
      gap: 0.6rem;
      align-items: center;
    }
    .risk-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      border-radius: 999px;
      padding: 0.28rem 0.8rem;
      font-size: 0.62rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      border: 1px solid rgba(255,255,255,0.08);
    }
    .risk-normal {
      background: rgba(0, 140, 70, 0.25);
      border-color: rgba(0, 140, 70, 0.4);
      color: #7dffb0;
    }
    .risk-elevated {
      background: rgba(255, 175, 0, 0.2);
      border-color: rgba(255, 175, 0, 0.5);
      color: #ffd599;
    }
    .risk-high {
      background: rgba(255, 80, 0, 0.28);
      border-color: rgba(255, 80, 0, 0.5);
      color: #ffb199;
    }
    .risk-critical {
      background: rgba(255, 0, 0, 0.3);
      border-color: rgba(255, 0, 0, 0.55);
      color: #ff9e9e;
    }
    .score-block {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.15rem;
      font-family: "Space Grotesk", sans-serif;
    }
    .score-label {
      font-size: 0.62rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(255,255,255,0.6);
    }
    .score-value {
      font-size: 1.32rem;
      font-weight: 700;
    }
    .score-raw {
      font-size: 0.6rem;
      color: rgba(255,255,255,0.55);
      text-transform: uppercase;
    }
    .result-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 0.9rem;
    }
    .result-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 0.9rem;
      padding: 0.75rem 0.9rem;
      backdrop-filter: blur(6px);
      position: relative;
      overflow: hidden;
    }
    .result-card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 15% 15%, rgba(255,255,255,0.08), transparent 60%);
      opacity: 0.35;
      pointer-events: none;
    }
    .result-card > * {
      position: relative;
      z-index: 1;
    }
    .result-card h4 {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.09em;
      margin-bottom: 0.55rem;
      color: rgba(255,255,255,0.92);
    }
    .result-list {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-size: 0.72rem;
      color: rgba(255,255,255,0.86);
    }
    .result-list li {
      display: flex;
      justify-content: space-between;
      gap: 0.65rem;
    }
    .result-list li span:last-child {
      color: rgba(255,255,255,0.56);
      font-size: 0.6rem;
    }
    #featureList li {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.35rem;
    }
    #featureList li span:last-child {
      align-self: flex-end;
      font-size: 0.58rem;
      color: rgba(255,255,255,0.48);
    }
    .feature-meter {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(255,255,255,0.08);
      overflow: hidden;
    }
    .feature-meter .fill {
      height: 100%;
      background: linear-gradient(120deg, rgba(255, 94, 0, 0.85), rgba(255, 150, 0, 0.85));
      border-radius: inherit;
      transition: width 0.35s ease;
    }
    .result-grid + .result-grid {
      margin-top: 0.9rem;
    }
    .insight-deck {
      margin-top: 1rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.85rem;
    }
    .insight-card {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 0.9rem;
      padding: 0.75rem 0.85rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      min-height: 120px;
    }
    .insight-title {
      font-size: 0.58rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.65);
    }
    .insight-value {
      font-size: 0.98rem;
      font-weight: 600;
      color: rgba(255,255,255,0.92);
    }
    .insight-sub {
      font-size: 0.6rem;
      color: rgba(255,255,255,0.58);
    }
    .insight-actions {
      list-style: none;
      padding-left: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      font-size: 0.6rem;
      color: rgba(255,255,255,0.7);
    }
    .insight-actions li {
      background: rgba(255,255,255,0.04);
      border-radius: 0.6rem;
      padding: 0.35rem 0.55rem;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .chart-deck {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
      margin-top: 2rem;
    }
    .chart-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 1rem;
      padding: 0.8rem 0.9rem 1.1rem;
      min-height: 260px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.55);
      backdrop-filter: blur(8px);
    }
    .chart-card h4 {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 0.6rem;
      color: rgba(255,255,255,0.82);
    }
    .chart-subtitle {
      font-size: 0.6rem;
      color: rgba(255,255,255,0.58);
      margin-bottom: 0.35rem;
      letter-spacing: 0.04em;
    }
    .chart-canvas {
      width: 100%;
      height: 220px;
    }
    .chart-placeholder {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      font-size: 0.62rem;
      text-align: center;
      color: rgba(255,255,255,0.58);
      border: 1px dashed rgba(255,255,255,0.18);
      border-radius: 0.75rem;
      padding: 0.6rem;
      background: rgba(0,0,0,0.3);
    }
    .notes-list {
      margin-top: 0.2rem;
      list-style: none;
      padding-left: 0;
      font-size: 0.64rem;
      color: rgba(255,255,255,0.72);
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .notes-list li::before {
      content: "•";
      color: rgba(255,94,0,0.8);
      margin-right: 0.45rem;
    }
    .notes-list li {
      display: flex;
      align-items: flex-start;
    }
    .notes-list li::before {
      margin-top: 0.12rem;
    }

    /* TRAINING DATA */
    .data-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1rem;
    }
    .data-card {
      background: rgba(0, 0, 0, 0.26);
      border: 1px solid rgba(255,255,255,0.015);
      border-radius: 1rem;
      padding: 0.9rem 1rem;
    }

    /* METADATA */
    .meta-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.1rem;
      margin-top: 1.3rem;
    }
    .stats-list {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.65rem;
      color: rgba(255,255,255,0.72);
    }
    .stats-list li {
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .stats-list span:last-child {
      color: rgba(255,255,255,0.5);
    }
    .threshold-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 0.35rem;
      margin-top: 0.5rem;
    }
    .threshold-pill {
      font-size: 0.58rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      padding: 0.25rem 0.55rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.05);
      color: rgba(255,255,255,0.75);
    }
    .feature-hints {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
      font-size: 0.63rem;
      color: rgba(255,255,255,0.73);
    }
    .feature-hints li strong {
      display: block;
      font-size: 0.66rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(255,255,255,0.8);
    }
    .release-notes {
      list-style: disc;
      padding-left: 1rem;
      font-size: 0.63rem;
      color: rgba(255,255,255,0.7);
    }

    /* FOOTER */
    footer {
      padding: 1.5rem min(5vw, 4rem);
      border-top: 1px solid rgba(255,255,255,0.04);
      text-align: center;
      color: rgba(255,255,255,0.35);
      font-size: 0.62rem;
      margin-top: 2.5rem;
    }

    @media (max-width: 980px) {
      .arch-grid {
        grid-template-columns: 1fr;
      }
      .page {
        padding-inline: 1rem;
      }
      .page-shell {
        width: 100%;
        gap: 2rem;
      }
      .result-head {
        flex-direction: column;
        align-items: flex-start;
      }
      .score-block {
        align-items: flex-start;
      }
      .chart-card {
        min-height: 240px;
      }
      .chart-canvas {
        height: 200px;
      }
      .insight-deck {
        grid-template-columns: 1fr;
      }
      .ops-grid {
        grid-template-columns: 1fr;
      }
      .inference-shell {
        grid-template-columns: 1fr;
        gap: 1.2rem;
      }
    }
    /* Added for appended t2 section */
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }
    @media (max-width: 980px) {
      .crash-analysis-grid,
      .feature-visual-grid {
        grid-template-columns: 1fr !important;
      }
    }
    @media (max-width: 720px) {
      nav {
        padding: 1rem 1.2rem;
        flex-wrap: wrap;
      }
      nav .logo {
        font-size: 0.9rem;
      }
      .nav-cta {
        font-size: 0.75rem;
        padding: 0.5rem 1.1rem;
      }
    }
  </style>
</head>
<body>

  <!-- Nav -->
  <nav>
    <a href="index1.html" class="logo"><span class="logo-dot"></span> VISIONALTRIX</a>
    <a href="index1.html#why" class="nav-cta">Why F1</a>
    <a href="ai-model.html" class="nav-cta">AI Model Training</a>
    <a href="visual.html" class="nav-cta">Live Safety Demo</a>
    <a href="result.html" class="nav-cta">Results</a>
  </nav>

  <main class="page">
    <div class="page-shell">

      <section class="inference-section">
      <div class="inference-header">
        <h2>Run Live Inference</h2>
      </div>
      <div class="inference-shell">
        <div class="inference-panel">
          <div class="model-chip" id="modelChip">Loading model metadata…</div>
          <label for="telemetry">Paste telemetry window (JSON or key:value)</label>
          <textarea id="telemetry" rows="4" placeholder="speed: 214, yaw_rate: 17.6, lateral_g: 3.2, brake_pressure: 0.4"></textarea>
          <p class="conditions-note">Optional environment context refines crash probability.</p>
        <div class="conditions-grid">
          <div class="field">
            <label for="weather">Weather</label>
            <select id="weather">
              <option value="">Auto-detect</option>
              <option>Dry</option>
              <option>Cloudy</option>
              <option>Light rain</option>
              <option>Rain</option>
              <option>Heavy rain</option>
              <option>Storm</option>
              <option>Fog</option>
              <option>Snow</option>
            </select>
          </div>
          <div class="field">
            <label for="trackTemp">Track temp (°C)</label>
            <input type="number" id="trackTemp" placeholder="38" />
          </div>
          <div class="field">
            <label for="humidity">Humidity (%)</label>
            <input type="number" id="humidity" placeholder="72" />
          </div>
          <div class="field">
            <label for="trackSurface">Track surface</label>
            <select id="trackSurface">
              <option value="">Select</option>
              <option>Track</option>
              <option>Street</option>
              <option>Wet</option>
              <option>Gravel</option>
              <option>Urban</option>
            </select>
          </div>
          <div class="field">
            <label for="visibility">Visibility</label>
            <select id="visibility">
              <option value="">Normal</option>
              <option>Excellent</option>
              <option>Good</option>
              <option>Moderate</option>
              <option>Poor</option>
              <option>Very poor</option>
            </select>
          </div>
          <div class="field">
            <label for="trafficDensity">Traffic density</label>
            <select id="trafficDensity">
              <option value="">Nominal</option>
              <option>Low</option>
              <option>Medium</option>
              <option>High</option>
              <option>Heavy</option>
            </select>
          </div>
          <div class="field">
            <label for="tyreWear">Tyre wear</label>
            <select id="tyreWear">
              <option value="">Baseline</option>
              <option>Fresh</option>
              <option>Scrubbed</option>
              <option>Worn</option>
              <option>Critical</option>
            </select>
          </div>
          <div class="field">
            <label for="driverState">Driver state</label>
            <select id="driverState">
              <option value="">Nominal</option>
              <option>Focused</option>
              <option>Alert</option>
              <option>Fatigued</option>
              <option>Distracted</option>
              <option>Aggressive</option>
              <option>Injured</option>
            </select>
          </div>
        </div>
        <div class="input-actions">
          <button class="ghost-btn" id="exampleBtn">Load demo sample</button>
          <button class="ghost-btn" id="clearBtn">Clear</button>
        </div>
        <button class="run-btn" id="runBtn">Run anomaly detection</button>
        <div class="infer-output" id="inferStatus">Awaiting input…</div>
        <div class="infer-results hidden fade-up" id="inferResults">
          <div class="result-head">
            <span class="risk-badge risk-normal" id="riskBadge">Normal</span>
            <div class="score-block">
              <span class="score-label">Crash probability</span>
              <span class="score-value" id="probabilityValue">0.0%</span>
              <span class="score-raw" id="severityLabel">Severity idx 0.0</span>
              <span class="score-raw" id="anomalyLabel">Anomaly 0.0000 · err 0.000000</span>
            </div>
          </div>
          <div class="result-grid">
            <div class="result-card">
              <h4>Mitigation actions</h4>
              <ul class="result-list" id="actionList">
                <li><span>None required</span><span>—</span></li>
              </ul>
            </div>
            <div class="result-card">
              <h4>Top feature deviations</h4>
              <ul class="result-list" id="featureList">
                <li><span>speed</span><span>0.0000</span></li>
              </ul>
            </div>
            <div class="result-card">
              <h4>Probability drivers</h4>
              <ul class="result-list" id="probabilityComponents">
                <li><span>Base anomaly</span><span>0.00</span></li>
              </ul>
            </div>
          </div>
          <div class="result-grid">
            <div class="result-card">
              <h4>Environment snapshot</h4>
              <ul class="notes-list" id="environmentList">
                <li>Environment insights will appear here.</li>
              </ul>
            </div>
            <div class="result-card">
              <h4>Risk notes</h4>
              <ul class="notes-list" id="notesList">
                <li>Inference notes will appear here.</li>
              </ul>
            </div>
          </div>
        </div>
        <div class="insight-deck hidden fade-up" id="insightDeck">
          <div class="insight-card">
            <span class="insight-title">Risk posture</span>
            <span class="insight-value" id="summaryLabel">Awaiting inference…</span>
            <span class="insight-sub" id="scenarioTag">—</span>
          </div>
          <div class="insight-card">
            <span class="insight-title">Dominant feature</span>
            <span class="insight-value" id="keyFeatureLabel">—</span>
            <span class="insight-sub">Highest reconstruction drift</span>
          </div>
          <div class="insight-card">
            <span class="insight-title">Environment impact</span>
            <span class="insight-value" id="envImpactLabel">—</span>
            <span class="insight-sub">Weather &amp; context modifier</span>
          </div>
          <div class="insight-card">
            <span class="insight-title">Actions armed</span>
            <span class="insight-value" id="actionsBadge">0</span>
            <ul class="insight-actions" id="actionHighlightList">
              <li>Awaiting inference…</li>
            </ul>
          </div>
        </div>
      </div>
    </section>
      <!-- Appended content from t2.html -->
      <section>
        <!-- Crash Analysis Showcase -->
        <h2 class="section-title">Live Crash Analysis Pipeline</h2>
        <p class="section-sub">See how VISIONALTRIX processes F1 telemetry in real-time, extracts crash signatures, and transfers learned patterns to consumer ADAS training datasets.</p>

        <!-- Quick Stats Banner -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 0.9rem; margin: 1.5rem 0 2rem;">
          <div class="arch-card" style="padding: 0.9rem 1rem; text-align: center;">
            <div id="statCrashes" style="font-size: 1.65rem; font-weight: 700; color: #ff5e00; font-family: 'Space Grotesk', sans-serif;">12,746</div>
            <div style="font-size: 0.62rem; text-transform: uppercase; letter-spacing: 0.08em; color: rgba(255,255,255,0.65); margin-top: 0.2rem;">Crashes Processed</div>
          </div>
          <div class="arch-card" style="padding: 0.9rem 1rem; text-align: center;">
            <div id="statSignatures" style="font-size: 1.65rem; font-weight: 700; color: #ff5e00; font-family: 'Space Grotesk', sans-serif;">418</div>
            <div style="font-size: 0.62rem; text-transform: uppercase; letter-spacing: 0.08em; color: rgba(255,255,255,0.65); margin-top: 0.2rem;">Unique Signatures</div>
          </div>
          <div class="arch-card" style="padding: 0.9rem 1rem; text-align: center;">
            <div id="statGain" style="font-size: 1.65rem; font-weight: 700; color: #ff5e00; font-family: 'Space Grotesk', sans-serif;">+82 ms</div>
            <div style="font-size: 0.62rem; text-transform: uppercase; letter-spacing: 0.08em; color: rgba(255,255,255,0.65); margin-top: 0.2rem;">Mean Prediction Gain</div>
          </div>
        </div>

        <!-- Crash Analysis Grid -->
        <div style="display: grid; grid-template-columns: 0.85fr 1.15fr; gap: 1.2rem; margin-bottom: 1.5rem;" class="crash-analysis-grid">
          <!-- Left: Crash Snapshot -->
          <div class="arch-card">
            <h3 style="margin-bottom: 0.8rem; font-size: 0.92rem;">Crash Snapshot</h3>
            <div style="display: flex; flex-direction: column; gap: 0.55rem;">
              <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.4rem 0; border-bottom: 1px solid rgba(255,255,255,0.06);">
                <span style="font-size: 0.68rem; color: rgba(255,255,255,0.65); text-transform: uppercase; letter-spacing: 0.06em;">Crash ID</span>
                <span id="snapshotCrashId" style="font-size: 0.72rem; font-family: 'Space Grotesk', sans-serif; color: #ff5e00; font-weight: 600;">F1-A17-SPA-2020</span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.4rem 0; border-bottom: 1px solid rgba(255,255,255,0.06);">
                <span style="font-size: 0.68rem; color: rgba(255,255,255,0.65); text-transform: uppercase; letter-spacing: 0.06em;">Speed Before Impact</span>
                <span id="snapshotSpeed" style="font-size: 0.72rem; font-family: 'Space Grotesk', sans-serif; color: rgba(255,255,255,0.9); font-weight: 600;">305 km/h</span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.4rem 0; border-bottom: 1px solid rgba(255,255,255,0.06);">
                <span style="font-size: 0.68rem; color: rgba(255,255,255,0.65); text-transform: uppercase; letter-spacing: 0.06em;">Impact Angle</span>
                <span id="snapshotAngle" style="font-size: 0.72rem; font-family: 'Space Grotesk', sans-serif; color: rgba(255,255,255,0.9); font-weight: 600;">28.4°</span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.4rem 0; border-bottom: 1px solid rgba(255,255,255,0.06);">
                <span style="font-size: 0.68rem; color: rgba(255,255,255,0.65); text-transform: uppercase; letter-spacing: 0.06em;">Peak G-Force</span>
                <span id="snapshotLatG" style="font-size: 0.72rem; font-family: 'Space Grotesk', sans-serif; color: #ff3030; font-weight: 700;">51.7 G</span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.4rem 0;">
                <span style="font-size: 0.68rem; color: rgba(255,255,255,0.65); text-transform: uppercase; letter-spacing: 0.06em;">Peak Longitudinal G</span>
                <span id="snapshotLongG" style="font-size: 0.72rem; font-family: 'Space Grotesk', sans-serif; color: rgba(255,255,255,0.9); font-weight: 600;">-5.1 G</span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.4rem 0;">
                <span style="font-size: 0.68rem; color: rgba(255,255,255,0.65); text-transform: uppercase; letter-spacing: 0.06em;">Window</span>
                <span id="snapshotWindow" style="font-size: 0.72rem; font-family: 'Space Grotesk', sans-serif; color: rgba(255,255,255,0.9); font-weight: 600;">2.0 s @ 50 Hz</span>
              </div>
            </div>
          </div>

          <!-- Right: Live Telemetry Graph -->
            <div class="arch-card telemetry-wrap">
    <h3>Live Telemetry Stream</h3>
    <div id="telemetryChart"></div>
  </div>

        <!-- AI Feature Extraction + F1 Visual -->
        <div style="display: grid; grid-template-columns: 1.2fr 0.8fr; gap: 1.2rem; margin-bottom: 1.5rem;" class="feature-visual-grid">
          <!-- Left: AI Feature Extraction -->
          <div class="arch-card">
            <h3 style="margin-bottom: 0.8rem; font-size: 0.92rem;">AI Feature Extraction</h3>
            <p style="font-size: 0.68rem; color: rgba(255,255,255,0.65); margin-bottom: 1rem; line-height: 1.5;">Patterns automatically learned from F1 crashes and exported to ADAS training datasets.</p>
            <div id="featureExtractionList" style="display: flex; flex-direction: column; gap: 0.65rem;">
              <div style="display: flex; align-items: center; gap: 0.6rem; background: rgba(0,255,100,0.08); border: 1px solid rgba(0,255,100,0.25); border-radius: 0.7rem; padding: 0.55rem 0.75rem;">
                <span style="font-size: 1.1rem;">✓</span>
                <div style="flex: 1;">
                  <div style="font-size: 0.7rem; font-weight: 600; color: #7dffb0; font-family: 'Space Grotesk', sans-serif;">decel-spike-longitudinal</div>
                  <div style="font-size: 0.6rem; color: rgba(255,255,255,0.6); margin-top: 0.15rem;">Sudden deceleration pattern detected</div>
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 0.6rem; background: rgba(0,255,100,0.08); border: 1px solid rgba(0,255,100,0.25); border-radius: 0.7rem; padding: 0.55rem 0.75rem;">
                <span style="font-size: 1.1rem;">✓</span>
                <div style="flex: 1;">
                  <div style="font-size: 0.7rem; font-weight: 600; color: #7dffb0; font-family: 'Space Grotesk', sans-serif;">steering-jitter-pattern</div>
                  <div style="font-size: 0.6rem; color: rgba(255,255,255,0.6); margin-top: 0.15rem;">High-frequency steering oscillations</div>
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 0.6rem; background: rgba(0,255,100,0.08); border: 1px solid rgba(0,255,100,0.25); border-radius: 0.7rem; padding: 0.55rem 0.75rem;">
                <span style="font-size: 1.1rem;">✓</span>
                <div style="flex: 1;">
                  <div style="font-size: 0.7rem; font-weight: 600; color: #7dffb0; font-family: 'Space Grotesk', sans-serif;">yaw-rate &gt; threshold</div>
                  <div style="font-size: 0.6rem; color: rgba(255,255,255,0.6); margin-top: 0.15rem;">Excessive rotation rate detected</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Right: F1 Vehicle Sensor Visual -->
          <div class="arch-card">
            <h3 style="margin-bottom: 0.8rem; font-size: 0.92rem;">Sensor Network</h3>
            <div id="f1Visual" style="width: 100%; height: 240px; display: flex; align-items: center; justify-content: center; position: relative;">
              <!-- F1 Car Outline with Sensors -->
              <svg viewBox="0 0 200 280" style="width: 100%; height: 100%; max-width: 180px;">
                <!-- Car Body -->
                <path d="M100,20 L110,30 L115,60 L120,100 L120,180 L115,220 L110,250 L100,260 L90,250 L85,220 L80,180 L80,100 L85,60 L90,30 Z" 
                      fill="rgba(255,255,255,0.03)" stroke="rgba(255,255,255,0.25)" stroke-width="1.5"/>
                
                <!-- Front Wing -->
                <rect x="75" y="25" width="50" height="3" rx="1.5" fill="rgba(255,255,255,0.15)"/>
                
                <!-- Rear Wing -->
                <rect x="75" y="252" width="50" height="3" rx="1.5" fill="rgba(255,255,255,0.15)"/>
                
                <!-- Wheels -->
                <ellipse cx="75" cy="70" rx="8" ry="14" fill="rgba(255,255,255,0.08)" stroke="rgba(255,255,255,0.25)" stroke-width="1"/>
                <ellipse cx="125" cy="70" rx="8" ry="14" fill="rgba(255,255,255,0.08)" stroke="rgba(255,255,255,0.25)" stroke-width="1"/>
                <ellipse cx="75" cy="210" rx="8" ry="14" fill="rgba(255,255,255,0.08)" stroke="rgba(255,255,255,0.25)" stroke-width="1"/>
                <ellipse cx="125" cy="210" rx="8" ry="14" fill="rgba(255,255,255,0.08)" stroke="rgba(255,255,255,0.25)" stroke-width="1"/>
                
                <!-- Sensor Dots (animated) -->
                <circle class="sensor-dot" cx="100" cy="20" r="3" fill="#ff5e00" opacity="0.9">
                  <animate attributeName="opacity" values="0.9;0.3;0.9" dur="1.5s" repeatCount="indefinite"/>
                </circle>
                <circle class="sensor-dot" cx="70" cy="100" r="3" fill="#ff5e00" opacity="0.7">
                  <animate attributeName="opacity" values="0.7;0.3;0.7" dur="1.8s" repeatCount="indefinite"/>
                </circle>
                <circle class="sensor-dot" cx="130" cy="100" r="3" fill="#ff5e00" opacity="0.7">
                  <animate attributeName="opacity" values="0.7;0.3;0.7" dur="1.8s" repeatCount="indefinite"/>
                </circle>
                <circle class="sensor-dot" cx="100" cy="140" r="3" fill="#ffaa00" opacity="0.8">
                  <animate attributeName="opacity" values="0.8;0.4;0.8" dur="2s" repeatCount="indefinite"/>
                </circle>
                <circle class="sensor-dot" cx="100" cy="260" r="3" fill="#ff5e00" opacity="0.9">
                  <animate attributeName="opacity" values="0.9;0.3;0.9" dur="1.6s" repeatCount="indefinite"/>
                </circle>
                
                <!-- Sensor Labels -->
                <text x="100" y="12" font-size="7" fill="rgba(255,255,255,0.7)" text-anchor="middle" font-family="Poppins">Front Impact</text>
                <text x="55" y="103" font-size="7" fill="rgba(255,255,255,0.7)" text-anchor="end" font-family="Poppins">Side L</text>
                <text x="145" y="103" font-size="7" fill="rgba(255,255,255,0.7)" text-anchor="start" font-family="Poppins">Side R</text>
                <text x="100" y="155" font-size="7" fill="rgba(255,255,255,0.7)" text-anchor="middle" font-family="Poppins">Driver Cell</text>
                <text x="100" y="274" font-size="7" fill="rgba(255,255,255,0.7)" text-anchor="middle" font-family="Poppins">Rear Impact</text>
              </svg>
            </div>
            <p id="sensorSummaryText" style="font-size: 0.62rem; color: rgba(255,255,255,0.55); text-align: center; margin-top: 0.5rem;">26 active sensor channels at 1000 Hz</p>
          </div>
        </div>

        <!-- Transfer Indicator -->
        <div class="arch-card" style="margin-bottom: 2rem;">
          <div style="display: flex; align-items: center; justify-content: space-between; gap: 1.5rem; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 240px;">
              <h3 style="margin-bottom: 0.5rem; font-size: 0.92rem;">F1 → Consumer ADAS Transfer</h3>
              <p style="font-size: 0.68rem; color: rgba(255,255,255,0.65); line-height: 1.5;">Learned crash signatures are automatically transferred to consumer vehicle ADAS training modules, improving prediction accuracy by an average of 82 milliseconds.</p>
            </div>
            <div style="flex: 1; min-width: 280px;">
              <div style="display: flex; align-items: center; gap: 0.8rem; margin-bottom: 0.5rem;">
                <span style="font-size: 0.62rem; text-transform: uppercase; letter-spacing: 0.08em; color: rgba(255,255,255,0.65);">Transfer Progress</span>
                <span style="font-size: 0.7rem; font-weight: 600; color: #ff5e00; font-family: 'Space Grotesk', sans-serif;">89%</span>
              </div>
              <div style="width: 100%; height: 12px; background: rgba(255,255,255,0.08); border-radius: 999px; overflow: hidden; position: relative;">
                <div id="transferBar" style="height: 100%; width: 89%; background: linear-gradient(90deg, #ff5e00, #ffaa00); border-radius: 999px; transition: width 0.4s ease;"></div>
                <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); animation: shimmer 2s infinite;"></div>
              </div>
              <div style="display: flex; justify-content: space-between; margin-top: 0.4rem; font-size: 0.58rem; color: rgba(255,255,255,0.5);">
                <span>F1 Crash Dataset</span>
                <span style="display: flex; align-items: center; gap: 0.3rem;">
                  <span style="animation: pulse 1.5s infinite;">→</span>
                  ADAS Training Module
                </span>
              </div>
            </div>
          </div>
        </div>
      </section>
   
      
    </div>
  </main>

  <footer>
    © 2025 VISIONALTRIX — AI Model Page
  </footer>

    <script>
    // GSAP basic reveal
    gsap.registerPlugin(ScrollTrigger);
    gsap.from(".title", { y: 20, opacity: 0, duration: 0.5 });
    gsap.utils.toArray(".pipe-card, .arch-card, .data-card").forEach((el) => {
      gsap.from(el, {
        scrollTrigger: {
          trigger: el,
          start: "top 85%",
        },
        y: 18,
        opacity: 0,
        duration: 0.4,
      });
    });

    // Default API base; prioritize current origin, then try defaults
    let apiBase = "";
    try {
      // First check URL parameters
      const params = new URLSearchParams(window.location.search || "");
      const overrideBase = params.get("API_BASE") || params.get("api_base");
      if (overrideBase) {
        apiBase = overrideBase;
      } else if (window.location.protocol === "file:") {
        // If file:// protocol, default to localhost:8000 (FastAPI default)
        apiBase = "http://127.0.0.1:8000";
      } else if (window.location.origin && (window.location.protocol === "http:" || window.location.protocol === "https:")) {
        // If served over HTTP/HTTPS, use current origin
        apiBase = window.location.origin;
      }
      
      // Fallback to localStorage if still empty
      if (!apiBase) {
        const saved = localStorage.getItem("apiBase");
        if (saved) apiBase = saved;
      }
    } catch (e) {
      console.warn("Error setting API base:", e);
    }

    const normalizeBase = (base) => {
      if (!base) return "";
      let out = String(base).trim();
      if (out && !/^https?:\/\//i.test(out)) { out = "http://" + out; }
      return out.endsWith("/") ? out.slice(0, -1) : out;
    };

    const apiUrl = (path, base = apiBase) => `${normalizeBase(base)}${path}`;

    const state = {
      metadata: null,
      actionLookup: {},
    };

    const telemetryField = document.getElementById("telemetry");
    const runBtn = document.getElementById("runBtn");
    const exampleBtn = document.getElementById("exampleBtn");
    const clearBtn = document.getElementById("clearBtn");
    const statusEl = document.getElementById("inferStatus");
    const resultsEl = document.getElementById("inferResults");
    const riskBadge = document.getElementById("riskBadge");
    const probabilityValue = document.getElementById("probabilityValue");
    const severityLabel = document.getElementById("severityLabel");
    const anomalyLabel = document.getElementById("anomalyLabel");
    const actionList = document.getElementById("actionList");
    const featureList = document.getElementById("featureList");
    const probabilityComponentsList = document.getElementById("probabilityComponents");
    const environmentList = document.getElementById("environmentList");
    const notesList = document.getElementById("notesList");
    const modelChip = document.getElementById("modelChip");

    const weatherField = document.getElementById("weather");
    const trackTempField = document.getElementById("trackTemp");
    const humidityField = document.getElementById("humidity");
    const trackSurfaceField = document.getElementById("trackSurface");
    const visibilityField = document.getElementById("visibility");
    const trafficField = document.getElementById("trafficDensity");
    const tyreWearField = document.getElementById("tyreWear");
    const driverStateField = document.getElementById("driverState");

    const chartDeck = document.getElementById("chartDeck");
    const probabilityGauge = document.getElementById("probabilityGauge");
    const timelineChart = document.getElementById("timelineChart");
    const threeDChart = document.getElementById("threeDChart");
    const threeDAxesLabel = document.getElementById("threeDAxes");
    const insightDeck = document.getElementById("insightDeck");
    const summaryLabel = document.getElementById("summaryLabel");
    const scenarioTag = document.getElementById("scenarioTag");
    const keyFeatureLabel = document.getElementById("keyFeatureLabel");
    const envImpactLabel = document.getElementById("envImpactLabel");
    const actionsBadge = document.getElementById("actionsBadge");
    const actionHighlightList = document.getElementById("actionHighlightList");
    const statCrashes = document.getElementById("statCrashes");
    const statSignatures = document.getElementById("statSignatures");
    const statGain = document.getElementById("statGain");
    const snapshotCrashId = document.getElementById("snapshotCrashId");
    const snapshotSpeed = document.getElementById("snapshotSpeed");
    const snapshotAngle = document.getElementById("snapshotAngle");
    const snapshotLatG = document.getElementById("snapshotLatG");
    const snapshotLongG = document.getElementById("snapshotLongG");
    const snapshotWindow = document.getElementById("snapshotWindow");
    const featureExtractionList = document.getElementById("featureExtractionList");
    const sensorSummaryText = document.getElementById("sensorSummaryText");
    const telemetryChartEl = document.getElementById("telemetryChart");

    const modelStatsList = document.getElementById("modelStatsList");
    const thresholdPills = document.getElementById("thresholdPills");
    const datasetStats = document.getElementById("datasetStats");
    const augmentationList = document.getElementById("augmentationList");
    const featureHintList = document.getElementById("featureHintList");
    const actionCatalogList = document.getElementById("actionCatalogList");
    const conditionList = document.getElementById("conditionList");
    const releaseNotes = document.getElementById("releaseNotes");

    const fallbackExample = "speed: 214, yaw_rate: 17.6, lateral_g: 3.2, brake_pressure: 0.4";

    const hasPlotly = () => typeof window !== "undefined" && !!window.Plotly;
    const DEFAULT_SAMPLE_RATE = 50;
    const DEFAULT_STATS = { crashes: 12746, signatures: 418, gain: 82 };
    const DEFAULT_FEATURE_ENTRIES = [
      { title: "decel-spike-longitudinal", detail: "Sudden deceleration pattern detected" },
      { title: "steering-jitter-pattern", detail: "High-frequency steering oscillations" },
      { title: "yaw-rate > threshold", detail: "Excessive rotation rate detected" },
    ];
    let runtimeStats = { ...DEFAULT_STATS };

    function formatLabel(label) {
      return label
        .toString()
        .replace(/_/g, " ")
        .replace(/\b([a-z])/g, (_, c) => c.toUpperCase());
    }

    const normalizeKey = (value) => String(value || "").toLowerCase().replace(/[^a-z0-9]+/g, "");

    function setRiskBadge(band = "normal") {
      const normalized = (band || "normal").toLowerCase();
      riskBadge.className = `risk-badge risk-${normalized}`;
      riskBadge.textContent = normalized;
    }

    function updateStatsDisplay() {
      if (statCrashes) statCrashes.textContent = runtimeStats.crashes.toLocaleString();
      if (statSignatures) statSignatures.textContent = runtimeStats.signatures.toLocaleString();
      if (statGain) statGain.textContent = `${runtimeStats.gain >= 0 ? "+" : ""}${runtimeStats.gain} ms`;
    }

    function setFeatureExtraction(items) {
      if (!featureExtractionList) return;
      const list = Array.isArray(items) && items.length ? items : DEFAULT_FEATURE_ENTRIES;
      featureExtractionList.innerHTML = list
        .map(
          (entry) => `
            <div style="display: flex; align-items: center; gap: 0.6rem; background: rgba(0,255,100,0.08); border: 1px solid rgba(0,255,100,0.25); border-radius: 0.7rem; padding: 0.55rem 0.75rem;">
              <span style="font-size: 1.1rem;">✓</span>
              <div style="flex: 1;">
                <div style="font-size: 0.7rem; font-weight: 600; color: #7dffb0; font-family: 'Space Grotesk', sans-serif;">${formatLabel(entry.title || "feature-pattern")}</div>
                <div style="font-size: 0.6rem; color: rgba(255,255,255,0.6); margin-top: 0.15rem;">${entry.detail || "Pattern detected during inference."}</div>
              </div>
            </div>
          `,
        )
        .join("");
    }

    function updateSensorSummary(topFeatures) {
      const names = Array.isArray(topFeatures) && topFeatures.length ? topFeatures : DEFAULT_FEATURE_ENTRIES.map((item) => item.title);
      if (sensorSummaryText) {
        sensorSummaryText.textContent = names.length
          ? `${names.slice(0, 4).map((name) => formatLabel(name)).join(", ")} sensors drove the latest anomaly.`
          : "26 active sensor channels at 50 Hz";
      }
    }

    function getSeriesFromResult(result, aliases) {
      const chartData = result?.chart_data || {};
      const topFeatures = Array.isArray(chartData.top_features) ? chartData.top_features : [];
      const normalizedTargets = aliases.map((alias) => normalizeKey(alias));

      const matchFromTop = topFeatures.find((series) => normalizedTargets.includes(normalizeKey(series.feature)));
      if (matchFromTop && Array.isArray(matchFromTop.values) && matchFromTop.values.length) {
        return matchFromTop.values.map((value) => Number(value)).filter((value) => Number.isFinite(value));
      }

      const rawSeq = Array.isArray(result?.raw_sequence) ? result.raw_sequence : [];
      const order = Array.isArray(result?.input_feature_order) ? result.input_feature_order : [];
      if (!rawSeq.length || !order.length) return [];
      const orderLookup = order.map((name) => normalizeKey(name));
      const idx = orderLookup.findIndex((key) => normalizedTargets.includes(key));
      if (idx === -1) return [];
      return rawSeq
        .map((row) => {
          if (Array.isArray(row)) return Number(row[idx]);
          if (row && typeof row === "object") {
            const keys = Object.keys(row);
            const matchKey = keys.find((key) => normalizeKey(key) === orderLookup[idx]);
            return Number(row[matchKey]);
          }
          return Number(row);
        })
        .filter((value) => Number.isFinite(value));
    }

    function renderTelemetryChart(data) {
      if (!telemetryChartEl) return;

      const speedSeries = getSeriesFromResult(data, ["speed", "speed_kmh", "vehicle_speed"]);
      const latSeries = getSeriesFromResult(data, ["lateral_g", "lat_g", "gz"]);
      const longSeries = getSeriesFromResult(data, ["longitudinal_g", "long_g", "ax"]);
      const timeline = Array.isArray(data?.chart_data?.timeline) ? data.chart_data.timeline : [];
      const lengths = [speedSeries.length, latSeries.length, longSeries.length, timeline.length].filter((len) => len > 0);
      const totalLen = lengths.length ? Math.max(...lengths) : 0;
      const sampleRate = Number(state.metadata?.expected_sample_rate_hz) || DEFAULT_SAMPLE_RATE;
      const windowSeconds = Number.isFinite(Number(data.seq_len)) ? Number(data.seq_len) / sampleRate : totalLen / sampleRate || 2;
      const dt = totalLen > 1 ? windowSeconds / (totalLen - 1) : windowSeconds || 0.02;
      const timeAxis = totalLen
        ? Array.from({ length: totalLen }, (_, index) => Number((index * dt).toFixed(2)))
        : Array.from({ length: speedSeries.length }, (_, index) => index * dt);

      if (!hasPlotly() || !totalLen) {
        if (hasPlotly()) Plotly.purge(telemetryChartEl);
        telemetryChartEl.innerHTML = `<div class="chart-placeholder">Run inference to stream live telemetry.</div>`;
        return;
      }

      const expandSeries = (values, fallback = 0) =>
        Array.from({ length: totalLen }, (_, index) => {
          if (!values.length) return fallback;
          const value = Number(values[Math.min(index, values.length - 1)]);
          return Number.isFinite(value) ? value : fallback;
        });

     const speed = expandSeries(speedSeries, 0);
     const longG = expandSeries(longSeries, 0);
     const reconErrors = timeline.map((point) => Number(point.recon_error) || 0);
     const maxError = reconErrors.length ? Math.max(...reconErrors) : 0;
     const baseRisk = Math.max(0, Math.min(1, Number(data.crash_probability) || 0));
      const riskSeries = totalLen
        ? Array.from({ length: totalLen }, (_, index) => {
            if (!reconErrors.length || maxError <= 0) return Math.round(baseRisk * 100);
            const value = reconErrors[Math.min(index, reconErrors.length - 1)];
            const scaled = Math.min(1, Math.max(0, (value / maxError) * baseRisk));
            return Math.round(scaled * 100);
          })
        : Array.from({ length: totalLen }, () => Math.round(baseRisk * 100));

      telemetryChartEl.innerHTML = "";
      Plotly.react(
        telemetryChartEl,
        [
          {
            x: timeAxis,
            y: speed,
            name: "Speed (km/h)",
            type: "scatter",
            mode: "lines",
            line: { color: "#f8f8f8", width: 2 },
          },
          {
            x: timeAxis,
            y: longG,
            name: "Longitudinal g",
            type: "scatter",
            mode: "lines",
            line: { color: "#ff3030", width: 2 },
            yaxis: "y2",
          },
          {
            x: timeAxis,
            y: riskSeries,
            name: "Risk (%)",
            type: "scatter",
            mode: "lines",
            line: { color: "#ff5e00", width: 2.5 },
            yaxis: "y3",
          },
        ],
        {
          margin: { t: 20, r: 45, l: 45, b: 35 },
          paper_bgcolor: "rgba(0,0,0,0)",
          plot_bgcolor: "rgba(0,0,0,0)",
          font: { color: "#f8f8f8", size: 10 },
          legend: { orientation: "h", x: 0.5, xanchor: "center", y: 1.12, font: { size: 9 } },
          xaxis: { title: "Time (s)", gridcolor: "rgba(255,255,255,0.08)" },
          yaxis: { title: "Speed", range: [0, Math.max(120, Math.max(...speed) * 1.15)], gridcolor: "rgba(255,255,255,0.08)" },
          yaxis2: { title: "Longitudinal g", overlaying: "y", side: "right", range: [Math.min(...longG, -2), Math.max(...longG, 2)], showgrid: false },
          yaxis3: { overlaying: "y", side: "right", position: 0.98, range: [0, 100], visible: false },
        },
        { responsive: true },
      );
    }

    function renderCrashSnapshot(data) {
      const latValues = getSeriesFromResult(data, ["lateral_g", "lat_g", "gz"]);
      const longValues = getSeriesFromResult(data, ["longitudinal_g", "long_g", "ax"]);
      const speedValues = getSeriesFromResult(data, ["speed", "speed_kmh", "vehicle_speed"]);
      const yawValues = getSeriesFromResult(data, ["yaw_rate", "yaw"]);
      const sampleRate = Number(state.metadata?.expected_sample_rate_hz) || DEFAULT_SAMPLE_RATE;
      const seqLen = Number.isFinite(Number(data.seq_len)) ? Number(data.seq_len) : Array.isArray(data.raw_sequence) ? data.raw_sequence.length : sampleRate * 2;
      const windowSeconds = seqLen ? (seqLen / sampleRate).toFixed(2) : "2.0";

      if (snapshotCrashId) snapshotCrashId.textContent = `LIVE-${String(Date.now()).slice(-6)}`;
      if (snapshotSpeed && speedValues.length) snapshotSpeed.textContent = `${Math.max(...speedValues).toFixed(1)} km/h`;
      if (snapshotAngle && yawValues.length) snapshotAngle.textContent = `${(Math.max(...yawValues.map((value) => Math.abs(value))) * 0.35).toFixed(1)}°`;
      if (snapshotLatG && latValues.length) snapshotLatG.textContent = `${Math.max(...latValues.map((value) => Math.abs(value))).toFixed(2)} g`;
      if (snapshotLongG && longValues.length) snapshotLongG.textContent = `${Math.min(...longValues).toFixed(2)} g`;
      if (snapshotWindow) snapshotWindow.textContent = `${windowSeconds} s @ ${sampleRate} Hz`;
    }

    function renderMetadata(meta) {
      state.metadata = meta;
      if (Array.isArray(meta.actions_catalog)) {
        state.actionLookup = Object.fromEntries(meta.actions_catalog.map((item) => [item.id, item.description]));
      }

      if (modelChip) {
        const seqInfo = meta.seq_len && meta.input_dim ? `${meta.seq_len}×${meta.input_dim}` : "unknown";
        modelChip.textContent = `Serving ${meta.model_version || "v?"} · ${String(meta.device || "cpu").toUpperCase()} (${seqInfo})`;
      }

      if (modelStatsList) {
        const sampleRateValue = Number(meta.expected_sample_rate_hz);
        const sampleRate = Number.isFinite(sampleRateValue) ? `${sampleRateValue} Hz` : "—";
        const durationValue = Number(meta.window_duration_s);
        const windowDuration = Number.isFinite(durationValue) ? `${durationValue.toFixed(2)}s` : "—";
        const latencyCpuValue = meta.latency_expectation_ms && Number(meta.latency_expectation_ms.cpu);
        const latencyCpu = Number.isFinite(latencyCpuValue) ? `${latencyCpuValue} ms` : "—";
        modelStatsList.innerHTML = `
          <li><span>Model version</span><span>${meta.model_version || "—"}</span></li>
          <li><span>Serving device</span><span>${meta.device || "—"}</span></li>
          <li><span>Window</span><span>${meta.seq_len || "?"}×${meta.input_dim || "?"} (${windowDuration})</span></li>
          <li><span>Sample rate</span><span>${sampleRate}</span></li>
          <li><span>Latency (CPU)</span><span>${latencyCpu}</span></li>
        `;
      }

      if (thresholdPills) {
        const entries = Object.entries(meta.score_thresholds || {});
        if (entries.length) {
          const sorted = entries.sort((a, b) => b[1] - a[1]);
          thresholdPills.innerHTML = sorted
            .map(([band, value]) => `<span class="threshold-pill">${band} ≥ ${value.toFixed(2)}</span>`)
            .join("");
        } else {
          thresholdPills.innerHTML = `<span class="threshold-pill">Thresholds unavailable</span>`;
        }
      }

      if (datasetStats) {
        const summary = meta.training_summary || {};
        const datasetLabel = typeof summary.dataset === "string" ? summary.dataset : "—";
        const totalSequences = Number(summary.total_sequences);
        const totalSteps = Number(summary.total_timesteps);
        const seqLen = Number(summary.sequence_length || meta.seq_len);
        datasetStats.innerHTML = `
          <li><span>Dataset</span><span>${datasetLabel}</span></li>
          <li><span>Total sequences</span><span>${Number.isFinite(totalSequences) ? totalSequences : "—"}</span></li>
          <li><span>Total timesteps</span><span>${Number.isFinite(totalSteps) ? totalSteps : "—"}</span></li>
          <li><span>Sequence length</span><span>${Number.isFinite(seqLen) ? seqLen : "—"}</span></li>
          <li><span>Epochs</span><span>${summary.epochs || "—"}</span></li>
        `;
        if (augmentationList) {
          const calibration = summary.reconstruction_error && typeof summary.reconstruction_error === "object"
            ? Object.entries(summary.reconstruction_error)
            : [];
          augmentationList.innerHTML = calibration.length
            ? calibration
                .filter(([key, value]) => value !== null && value !== undefined)
                .map(([key, value]) => {
                  const numeric = Number(value);
                  const formatted = Number.isFinite(numeric)
                    ? key === "sample_count"
                      ? numeric.toLocaleString()
                      : numeric.toFixed(4)
                    : value;
                  return `<li><strong>${formatLabel(key)}</strong><span>${formatted}</span></li>`;
                })
                .join("")
            : `<li>No calibration metrics reported.</li>`;
        }
      }
      runtimeStats = {
        crashes: Number.isFinite(Number(meta.training_summary?.total_sequences))
          ? Number(meta.training_summary.total_sequences)
          : DEFAULT_STATS.crashes,
        signatures: Number.isFinite(Number(meta.training_summary?.unique_signatures))
          ? Number(meta.training_summary.unique_signatures)
          : DEFAULT_STATS.signatures,
        gain: Number.isFinite(Number(meta.training_summary?.prediction_gain_ms))
          ? Number(meta.training_summary.prediction_gain_ms)
          : DEFAULT_STATS.gain,
      };
      updateStatsDisplay();

      if (featureHintList) {
        const hints = Array.isArray(meta.feature_hints) ? meta.feature_hints : [];
        featureHintList.innerHTML = hints.length
          ? hints
              .map(
                (item) => `
                  <li>
                    <strong>${item.name}</strong>
                    <span>${item.description || ""}${item.unit ? ` · ${item.unit}` : ""}</span>
                  </li>
                `,
              )
              .join("")
          : `<li>No feature hints provided.</li>`;
      }

      if (actionCatalogList) {
        const actions = Array.isArray(meta.actions_catalog) ? meta.actions_catalog : [];
        actionCatalogList.innerHTML = actions.length
          ? actions.map((action) => `<li><strong>${action.id}</strong><span>${action.description || ""}</span></li>`).join("")
          : `<li>No mitigation actions configured.</li>`;
      }

      if (conditionList) {
        const supported = Array.isArray(meta.supported_conditions) ? meta.supported_conditions : [];
        conditionList.innerHTML = supported.length
          ? supported
              .map((item) => `<li><strong>${formatLabel(item)}</strong><span>Recognised context input</span></li>`)
              .join("")
          : `<li>No environment inputs documented.</li>`;
      }

      if (releaseNotes) {
        const notes = Array.isArray(meta.release_notes) ? meta.release_notes : [];
        releaseNotes.innerHTML = notes.length
          ? notes.map((note) => `<li>${note}</li>`).join("")
          : `<li>No release notes available.</li>`;
      }

      if (statusEl && !telemetryField.value.trim()) {
        const baseHint = apiBase ? ` (API ${apiBase || window.location.origin})` : "";
        statusEl.textContent = `Metadata loaded${baseHint}. Paste telemetry to run inference.`;
      }
    }

    async function loadMetadata() {
      const candidateBases = [
        apiBase,
        window.location.origin && window.location.origin.startsWith("http") ? window.location.origin : "",
        "http://127.0.0.1:8000",
        "http://localhost:8000",
        "http://127.0.0.1:5501",
        "http://localhost:5501",
        "",
      ].filter((base, idx, arr) => base && base !== undefined && arr.indexOf(base) === idx && base.trim() !== "");

      let lastError = null;

      for (const candidate of candidateBases) {
        const normalized = normalizeBase(candidate);
        try {
          const response = await fetch(apiUrl("/api/model-metadata", normalized));
          if (!response.ok) {
            lastError = new Error(`Metadata request failed (${response.status})`);
            continue;
          }
          const data = await response.json();
          apiBase = normalized;
          renderMetadata(data);
          return;
        } catch (error) {
          lastError = error;
        }
      }

      if (modelChip) {
        const hint = apiBase ? ` (looking at ${apiBase})` : "";
        modelChip.textContent = `Metadata unavailable${hint}`;
      }
      if (conditionList) {
        conditionList.innerHTML = `<li>Metadata unavailable</li>`;
      }
      if (statusEl) {
        const message = lastError ? lastError.message : "Metadata fetch failed";
        statusEl.textContent = `⚠️ ${message}`;
      }
    }

    function renderActions(actions) {
      if (!actionList) return;
      if (!Array.isArray(actions) || actions.length === 0) {
        actionList.innerHTML = `<li><span>None required</span><span>—</span></li>`;
        return;
      }
      actionList.innerHTML = actions
        .map((action) => {
          const desc = state.actionLookup[action] || "Triggered automatically";
          return `<li><span>${formatLabel(action)}</span><span>${desc}</span></li>`;
        })
        .join("");
    }

    function renderFeatures(breakdown) {
      if (!featureList) return;
      const top = Array.isArray(breakdown) ? breakdown.slice(0, 5) : [];
      if (!top.length) {
        featureList.innerHTML = `
          <li>
            <span>No features available</span>
            <div class="feature-meter"><div class="fill" style="width:0%"></div></div>
            <span>—</span>
          </li>
        `;
        return;
      }
      featureList.innerHTML = top
        .map((item) => {
          const value = typeof item.recon_error === "number" ? item.recon_error : Number(item.recon_error) || 0;
          const importance = typeof item.scaled_importance === "number" ? item.scaled_importance : Number(item.scaled_importance) || 0;
          const clamped = Math.max(0, Math.min(1, importance));
          return `
            <li>
              <span>${formatLabel(item.feature)}</span>
              <div class="feature-meter"><div class="fill" style="width:${(clamped * 100).toFixed(0)}%"></div></div>
              <span>${value.toFixed(4)}</span>
            </li>
          `;
        })
        .join("");
    }

    function renderNotes(notes, extra) {
      if (!notesList) return;
      const base = Array.isArray(notes) ? notes : [];
      const extraNotes = Array.isArray(extra) ? extra : [];
      const combined = [...base, ...extraNotes];
      const list = combined.length ? combined : ["Telemetry reconstruction aligns with trained envelope."];
      notesList.innerHTML = list.map((note) => `<li>${note}</li>`).join("");
    }

    function renderProbabilityComponents(components) {
      if (!probabilityComponentsList) return;
      if (!Array.isArray(components) || components.length === 0) {
        probabilityComponentsList.innerHTML = `<li><span>Base anomaly</span><span>0.00</span></li>`;
        return;
      }
      probabilityComponentsList.innerHTML = components
        .map((item) => {
          const label = item.detail ? `${item.label}: ${formatLabel(item.detail)}` : item.label;
          const value = typeof item.value === "number" ? item.value : Number(item.value) || 0;
          const formatted = value >= 0 ? `+${value.toFixed(2)}` : value.toFixed(2);
          return `<li><span>${label}</span><span>${formatted}</span></li>`;
        })
        .join("");
    }

    function renderEnvironment(summary, contributors) {
      if (!environmentList) return;
      const lines = [];
      if (Array.isArray(summary) && summary.length) {
        summary.forEach((line) => lines.push(line));
      } else if (typeof summary === "string" && summary) {
        lines.push(summary);
      }
      if (Array.isArray(contributors) && contributors.length) {
        contributors.forEach((item) => {
          const detail = item.detail ? ` ${formatLabel(item.detail)}` : "";
          const delta = typeof item.delta === "number" ? item.delta : Number(item.value) || 0;
          const formatted = delta >= 0 ? `+${delta.toFixed(2)}` : delta.toFixed(2);
          lines.push(`${item.label || "Factor"}${detail}: ${formatted}`);
        });
      }
      environmentList.innerHTML = lines.length
        ? lines.map((line) => `<li>${line}</li>`).join("")
        : `<li>No environment context supplied.</li>`;
    }

    function setChartPlaceholder(node, message) {
      if (!node) return;
      node.innerHTML = `<div class="chart-placeholder">${message}</div>`;
    }

    function resetCharts() {
      if (chartDeck) {
        chartDeck.classList.add("hidden");
        chartDeck.classList.remove("visible");
      }
      if (insightDeck) {
        insightDeck.classList.add("hidden");
        insightDeck.classList.remove("visible");
      }
      if (hasPlotly()) {
        if (probabilityGauge) Plotly.purge(probabilityGauge);
        if (timelineChart) Plotly.purge(timelineChart);
        if (threeDChart) Plotly.purge(threeDChart);
      }
      if (probabilityGauge) probabilityGauge.innerHTML = "";
      if (timelineChart) timelineChart.innerHTML = "";
      if (threeDChart) threeDChart.innerHTML = "";
      if (threeDAxesLabel) threeDAxesLabel.textContent = "Axes: —";
      if (summaryLabel) summaryLabel.textContent = "Awaiting inference…";
      if (scenarioTag) scenarioTag.textContent = "—";
      if (keyFeatureLabel) keyFeatureLabel.textContent = "—";
      if (envImpactLabel) envImpactLabel.textContent = "—";
      if (actionsBadge) actionsBadge.textContent = "0";
      if (actionHighlightList) actionHighlightList.innerHTML = "<li>Awaiting inference…</li>";
      if (telemetryChartEl) {
        if (hasPlotly()) Plotly.purge(telemetryChartEl);
        telemetryChartEl.innerHTML = '<div class="chart-placeholder">Run inference to stream live telemetry.</div>';
      }
      setFeatureExtraction(DEFAULT_FEATURE_ENTRIES);
      updateSensorSummary([]);
      updateStatsDisplay();
    }

    function renderCharts(data) {
      if (!chartDeck) return;
      const chartData = data?.chart_data || {};
      if (!hasPlotly()) {
        chartDeck.classList.remove("hidden");
        chartDeck.classList.add("visible");
        setChartPlaceholder(probabilityGauge, "Load Plotly to render charts.");
        setChartPlaceholder(timelineChart, "Load Plotly to render charts.");
        setChartPlaceholder(threeDChart, "Load Plotly to render charts.");
        return;
      }

      chartDeck.classList.remove("hidden");
      chartDeck.classList.add("visible");

      const probability = Math.max(0, Math.min(1, Number(data.crash_probability) || 0)) * 100;
      const thresholds = Array.isArray(state.metadata?.chart_defaults?.gauge_thresholds)
        ? state.metadata.chart_defaults.gauge_thresholds.filter((v) => Number.isFinite(v))
        : [0.25, 0.55, 0.75, 0.9];
      const edges = [0, ...thresholds.map((v) => Math.max(0, Math.min(1, Number(v))))].sort((a, b) => a - b);
      if (edges[edges.length - 1] !== 1) edges.push(1);
      const colors = [
        "rgba(125,255,176,0.28)",
        "rgba(255,220,120,0.28)",
        "rgba(255,170,80,0.32)",
        "rgba(255,120,120,0.35)",
        "rgba(200,80,80,0.4)",
      ];
      const gaugeSteps = [];
      for (let i = 0; i < edges.length - 1; i += 1) {
        gaugeSteps.push({
          range: [edges[i] * 100, edges[i + 1] * 100],
          color: colors[i] || colors[colors.length - 1],
        });
      }

      Plotly.newPlot(
        probabilityGauge,
        [
          {
            type: "indicator",
            mode: "gauge+number",
            value: probability,
            number: { suffix: "%", font: { color: "#ffffff", size: 24 } },
            gauge: {
              axis: { range: [0, 100], tickcolor: "#999" },
              bar: { color: "#ff5e00" },
              steps: gaugeSteps,
              threshold: {
                line: { color: "#ffffff", width: 2 },
                value: probability,
              },
            },
          },
        ],
        {
          margin: { t: 20, b: 10, l: 10, r: 10 },
          paper_bgcolor: "rgba(0,0,0,0)",
          font: { color: "#f8f8f8" },
        },
        { responsive: true },
      );

      const timeline = Array.isArray(chartData.timeline) ? chartData.timeline : [];
      if (timeline.length && timelineChart) {
        Plotly.newPlot(
          timelineChart,
          [
            {
              x: timeline.map((point) => point.timestep),
              y: timeline.map((point) => point.recon_error),
              type: "scatter",
              mode: "lines+markers",
              line: { color: "#ff5e00" },
              marker: { color: "#ffb199", size: 5 },
            },
          ],
          {
            margin: { t: 20, r: 10, l: 35, b: 35 },
            paper_bgcolor: "rgba(0,0,0,0)",
            plot_bgcolor: "rgba(0,0,0,0)",
            font: { color: "#f8f8f8" },
            xaxis: { title: "timestep" },
            yaxis: { title: "recon error" },
          },
          { responsive: true },
        );
      } else if (timelineChart) {
        Plotly.purge(timelineChart);
        setChartPlaceholder(timelineChart, "Timeline will appear once a multi-step telemetry window is scored.");
      }

      const projection = chartData.three_d_projection || {};
      if (
        threeDChart &&
        Array.isArray(projection.axes) &&
        projection.axes.length === 3 &&
        Array.isArray(projection.points) &&
        projection.points.length >= 3
      ) {
        const axes = projection.axes.map((axis) => formatLabel(axis));
        if (threeDAxesLabel) {
          threeDAxesLabel.textContent = `Axes: ${axes.join(" · ")}`;
        }
        Plotly.newPlot(
          threeDChart,
          [
            {
              type: "scatter3d",
              mode: "lines+markers",
              x: projection.points.map((pt) => pt.x),
              y: projection.points.map((pt) => pt.y),
              z: projection.points.map((pt) => pt.z),
              marker: {
                size: 4,
                color: projection.points.map((pt) => pt.error),
                colorscale: "YlOrRd",
                colorbar: { title: "recon err" },
              },
              line: { color: "#ff5e00", width: 2 },
            },
          ],
          {
            margin: { t: 20, b: 0, l: 0, r: 0 },
            paper_bgcolor: "rgba(0,0,0,0)",
            scene: {
              xaxis: { title: axes[0], backgroundcolor: "rgba(0,0,0,0)" },
              yaxis: { title: axes[1], backgroundcolor: "rgba(0,0,0,0)" },
              zaxis: { title: axes[2], backgroundcolor: "rgba(0,0,0,0)" },
            },
          },
          { responsive: true },
        );
      } else if (threeDChart) {
        Plotly.purge(threeDChart);
        setChartPlaceholder(threeDChart, "3D trajectory activates when three distinct sensor signals are present.");
        if (threeDAxesLabel) threeDAxesLabel.textContent = "Axes: —";
      }
    }

    function collectConditions() {
      const conditions = {};
      if (weatherField && weatherField.value) conditions.weather = weatherField.value.toLowerCase();
      if (trackTempField && trackTempField.value !== "") {
        const value = Number(trackTempField.value);
        if (!Number.isNaN(value)) conditions.track_temperature = value;
      }
      if (humidityField && humidityField.value !== "") {
        const value = Number(humidityField.value);
        if (!Number.isNaN(value)) conditions.humidity = value;
      }
      if (trackSurfaceField && trackSurfaceField.value) conditions.track_surface = trackSurfaceField.value.toLowerCase();
      if (visibilityField && visibilityField.value) conditions.visibility = visibilityField.value.toLowerCase();
      if (trafficField && trafficField.value) conditions.traffic_density = trafficField.value.toLowerCase();
      if (tyreWearField && tyreWearField.value) conditions.tyre_wear = tyreWearField.value.toLowerCase();
      if (driverStateField && driverStateField.value) conditions.driver_state = driverStateField.value.toLowerCase();
      return conditions;
    }

    function renderInference(data) {
      resultsEl.classList.remove("hidden");
      resultsEl.classList.add("visible");
      const crashProbability = Math.max(0, Math.min(1, Number(data.crash_probability) || 0));
      if (probabilityValue) probabilityValue.textContent = `${(crashProbability * 100).toFixed(1)}%`;
      if (severityLabel) {
        const severity = Number(data.severity_index);
        severityLabel.textContent = Number.isFinite(severity) ? `Severity idx ${severity.toFixed(1)}` : "Severity idx —";
      }
      if (anomalyLabel) {
        const anomalyScore = Number(data.anomaly_score) || 0;
        const rawRecon = Number(data.raw_recon_error) || 0;
        anomalyLabel.textContent = `Anomaly ${anomalyScore.toFixed(4)} · err ${rawRecon.toFixed(6)}`;
      }
      setRiskBadge(data.risk_band || "normal");
      renderActions(data.actions);
      renderFeatures(data.feature_breakdown);
      renderProbabilityComponents(data.probability_components);
      renderEnvironment(data.condition_summary, data.condition_contributors);
      renderNotes(data.notes, data.domain_notes);
      renderCharts(data);
      renderTelemetryChart(data);
      renderCrashSnapshot(data);
      const featureEntries = Array.isArray(data.feature_breakdown)
        ? data.feature_breakdown.slice(0, 3).map((item) => ({
            title: item.feature,
            detail: `Reconstruction error ${Number(item.recon_error || 0).toFixed(3)}`,
          }))
        : [];
      setFeatureExtraction(featureEntries);
      updateSensorSummary(featureEntries.map((entry) => entry.title));
      runtimeStats.crashes += 1;
      if (featureEntries.length) {
        runtimeStats.signatures = Math.max(runtimeStats.signatures, DEFAULT_STATS.signatures + featureEntries.length);
      }
      if (Number.isFinite(Number(data.latency_ms))) {
        runtimeStats.gain = Math.max(10, Math.round(120 - Number(data.latency_ms)));
      }
      updateStatsDisplay();
      const latencyValue = Number(data.latency_ms);
      const latency = Number.isFinite(latencyValue) ? `${latencyValue.toFixed(2)} ms` : `${data.latency_ms || "—"} ms`;
      if (statusEl) statusEl.textContent = `Latency ${latency} · crash probability ${(crashProbability * 100).toFixed(1)}%`;
      const riskBand = (data.risk_band || "normal").toLowerCase();
      const scenarioCopy = {
        normal: {
          title: "Stable envelope",
          caption: "Telemetry in expected manifold",
        },
        elevated: {
          title: "Drift detected",
          caption: "Monitor assists & collect more laps",
        },
        high: {
          title: "High crash pressure",
          caption: "Prime mitigations & alert safety crew",
        },
        critical: {
          title: "Critical impact risk",
          caption: "Execute emergency playbook immediately",
        },
      };
      const copy = scenarioCopy[riskBand] || scenarioCopy.normal;
      const scenarioLabel = data.scenario_label ? formatLabel(data.scenario_label) : copy.caption;
      if (insightDeck) {
        insightDeck.classList.remove("hidden");
        insightDeck.classList.add("visible");
      }
      if (summaryLabel) summaryLabel.textContent = copy.title;
      if (scenarioTag) scenarioTag.textContent = scenarioLabel;
      const breakdownArray = Array.isArray(data.feature_breakdown) ? data.feature_breakdown : [];
      let dominant = null;
      if (data.dominant_feature) {
        const match = breakdownArray.find((item) => item.feature === data.dominant_feature);
        dominant = {
          feature: data.dominant_feature,
          recon_error: match ? match.recon_error : undefined,
        };
      } else if (breakdownArray.length) {
        dominant = breakdownArray[0];
      }
      if (keyFeatureLabel) {
        if (dominant) {
          keyFeatureLabel.textContent = `${formatLabel(dominant.feature)} · ${Number(dominant.recon_error || 0).toFixed(3)}`;
        } else {
          keyFeatureLabel.textContent = "—";
        }
      }
      const envLine = Array.isArray(data.condition_summary) && data.condition_summary.length ? data.condition_summary[0] : "No environment context supplied";
      const domainImpact = typeof data.domain_modifier === "number" ? `Telemetry heuristics ${data.domain_modifier >= 0 ? "+" : ""}${data.domain_modifier.toFixed(2)}` : "";
      if (envImpactLabel) envImpactLabel.textContent = domainImpact ? `${envLine} | ${domainImpact}` : envLine;
      const actions = Array.isArray(data.actions) ? data.actions : [];
      if (actionsBadge) actionsBadge.textContent = String(actions.length);
      if (actionHighlightList) {
        if (!actions.length) {
          actionHighlightList.innerHTML = "<li>No mitigation triggered.</li>";
        } else {
          actionHighlightList.innerHTML = actions
            .map((action) => {
              const desc = state.actionLookup[action] || "Automatic response";
              return `<li>${formatLabel(action)} — ${desc}</li>`;
            })
            .join("");
        }
      }
      if (window.gsap) {
        gsap.fromTo(resultsEl, { opacity: 0, y: 14 }, { opacity: 1, y: 0, duration: 0.35, ease: "power2.out" });
        if (insightDeck && insightDeck.classList.contains("visible")) {
          gsap.fromTo(insightDeck, { opacity: 0, y: 14 }, { opacity: 1, y: 0, duration: 0.33, ease: "power2.out", delay: 0.03 });
        }
        if (chartDeck && !chartDeck.classList.contains("hidden")) {
          gsap.fromTo(chartDeck, { opacity: 0, y: 16 }, { opacity: 1, y: 0, duration: 0.36, ease: "power2.out", delay: 0.05 });
        }
      }
    }

    async function handleInference() {
      const raw = telemetryField.value.trim();
      if (!raw) {
        if (statusEl) statusEl.textContent = "Paste telemetry before running inference.";
        resultsEl.classList.add("hidden");
        resultsEl.classList.remove("visible");
        resetCharts();
        return;
      }

      if (statusEl) statusEl.textContent = "Running inference…";
      resultsEl.classList.add("hidden");
      resultsEl.classList.remove("visible");
      resetCharts();

      try {
        const payload = { telemetry: raw };
        const context = {};
        if (state.metadata?.model_version) {
          context.requested_version = state.metadata.model_version;
        }
        if (Object.keys(context).length) {
          payload.context = context;
        }
        const conditions = collectConditions();
        if (Object.keys(conditions).length) {
          payload.conditions = conditions;
        }

        const response = await fetch(apiUrl("/api/infer"), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        if (!response.ok) {
          let message;
          const responseText = await response.text();
          try {
            const body = JSON.parse(responseText);
            message = body.detail || JSON.stringify(body);
          } catch (err) {
            message = responseText;
          }
          throw new Error(message || `Inference failed (${response.status})`);
        }

        const data = await response.json();
        renderInference(data);
      } catch (error) {
        if (statusEl) {
          const extra = window.location.protocol === "file:" ? ` · Hint: ensure the FastAPI server is reachable at ${apiBase || "http://127.0.0.1:8000"}` : "";
          statusEl.textContent = `⚠️ ${error.message}${extra}`;
        }
      }
    }

    function handleExample() {
      const example = state.metadata?.example_payload || fallbackExample;
      telemetryField.value = example;
      if (weatherField && !weatherField.value) weatherField.value = "Light rain";
      if (trackTempField && !trackTempField.value) trackTempField.value = "36";
      if (visibilityField && !visibilityField.value) visibilityField.value = "Moderate";
      if (statusEl) statusEl.textContent = "Demo telemetry loaded. Run anomaly detection to score.";
    }

    function handleClear() {
      telemetryField.value = "";
      if (weatherField) weatherField.value = "";
      if (trackTempField) trackTempField.value = "";
      if (humidityField) humidityField.value = "";
      if (trackSurfaceField) trackSurfaceField.value = "";
      if (visibilityField) visibilityField.value = "";
      if (trafficField) trafficField.value = "";
      if (tyreWearField) tyreWearField.value = "";
      if (driverStateField) driverStateField.value = "";
    resultsEl.classList.add("hidden");
    resultsEl.classList.remove("visible");
    resetCharts();
    if (statusEl) statusEl.textContent = "Cleared. Paste telemetry to run inference.";
  }

    updateStatsDisplay();
    setFeatureExtraction(DEFAULT_FEATURE_ENTRIES);
    updateSensorSummary([]);

    runBtn.addEventListener("click", handleInference);
    exampleBtn.addEventListener("click", handleExample);
    clearBtn.addEventListener("click", handleClear);
    telemetryField.addEventListener("keydown", (event) => {
      if ((event.metaKey || event.ctrlKey) && event.key === "Enter") {
        handleInference();
      }
    });

    loadMetadata();
    
    // Force refresh if page was loaded from cache
    window.addEventListener('pageshow', function(event) {
      if (event.persisted) {
        // Page was loaded from cache, force reload
        window.location.reload();
      }
    });
    
    // Clear old localStorage cache on version change
    const CURRENT_VERSION = '2.0.0';
    const storedVersion = localStorage.getItem('appVersion');
    if (storedVersion !== CURRENT_VERSION) {
      try {
        localStorage.removeItem('apiBase');
        localStorage.setItem('appVersion', CURRENT_VERSION);
        console.log('Cache cleared, app version updated to', CURRENT_VERSION);
      } catch (e) {
        console.warn('Could not update cache version:', e);
      }
    }
     (function initTelemetryChart() {
      const chartEl = document.getElementById("telemetryChart");
      if (!window.Plotly || !chartEl) return;

      const duration = 100; // number of data points
      let frame = 0;

      const generateData = () => {
        const data = [];
        for (let i = 0; i < duration; i++) {
          const t = i / duration;
          let speed = 305; // km/h
          if (t > 0.6) {
            const crashProgress = (t - 0.6) / 0.4;
            speed = 305 - crashProgress * crashProgress * 290;
          }
          let longG = 0.5 + Math.sin(i * 0.3) * 0.3;
          if (t > 0.6 && t < 0.75) {
            const spikeProgress = (t - 0.6) / 0.15;
            longG = Math.sin(spikeProgress * Math.PI) * 45 + 5;
          }
          let risk = 0.1 + Math.sin(i * 0.2) * 0.05;
          if (t > 0.5) {
            const riskProgress = (t - 0.5) / 0.5;
            risk = 0.15 + riskProgress * riskProgress * 0.82;
          }
          data.push({ time: i, speed, longG, risk });
        }
        return data;
      };

      const telemetryData = generateData();

      const speedTrace = { x: [], y: [], name: "Speed (km/h)", type: "scatter", mode: "lines", line: { color: "#f8f8f8", width: 2 } };
      const longGTrace = { x: [], y: [], name: "Longitudinal G", type: "scatter", mode: "lines", line: { color: "#ff3030", width: 2 }, yaxis: "y2" };
      const riskTrace  = { x: [], y: [], name: "Risk Score",     type: "scatter", mode: "lines", line: { color: "#ff5e00", width: 2.5 }, yaxis: "y3" };

      const layout = {
        margin: { t: 10, r: 45, l: 45, b: 30 },
        paper_bgcolor: "rgba(0,0,0,0)",
        plot_bgcolor: "rgba(0,0,0,0)",
        font: { color: "#f8f8f8", size: 10 },
        showlegend: true,
        legend: { x: 0.5, xanchor: "center", y: 1.15, orientation: "h", font: { size: 9 } },
        xaxis: { title: "Time (ms)", gridcolor: "rgba(255,255,255,0.08)", showgrid: true },
        yaxis:  { title: "Speed", gridcolor: "rgba(255,255,255,0.08)", side: "left", range: [0, 320] },
        yaxis2: { title: "G-Force", overlaying: "y", side: "right", range: [0, 60], showgrid: false },
        yaxis3: { overlaying: "y", side: "right", position: 0.98, range: [0, 1], showgrid: false, visible: false },
      };

      Plotly.newPlot(chartEl, [speedTrace, longGTrace, riskTrace], layout, { responsive: true });

      const animate = () => {
        if (frame >= duration) {
          frame = 0;
          speedTrace.x = speedTrace.y = longGTrace.x = longGTrace.y = riskTrace.x = riskTrace.y = [];
        }
        const point = telemetryData[frame];
        speedTrace.x.push(point.time);  speedTrace.y.push(point.speed);
        longGTrace.x.push(point.time);  longGTrace.y.push(point.longG);
        riskTrace.x.push(point.time);   riskTrace.y.push(point.risk);

        Plotly.update(chartEl,
          { x: [speedTrace.x, longGTrace.x, riskTrace.x], y: [speedTrace.y, longGTrace.y, riskTrace.y] },
          {}, [0, 1, 2]
        );
        frame++; setTimeout(animate, 50);
      };
      animate();
    })();
  </script>
  <script>
    // Unregister any service workers that might serve old content
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then((regs) => {
        regs.forEach((reg) => reg.unregister().catch(() => {}));
      }).catch(() => {});
    }
    // Append cache-busting param to internal .html links
    (function() {
      const version = Date.now().toString();
      document.querySelectorAll('nav a[href$=".html"]').forEach((a) => {
        try {
          const url = new URL(a.href, window.location.origin);
          url.searchParams.set('v', version);
          a.href = url.toString();
        } catch (_) {}
      });
    })();
  </script>
</body>
</html>

